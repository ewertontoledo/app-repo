name: Deploy Multi-Environment

on:
  push:
    branches: [ "develop", "stage", "prod" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente de deploy (develop, stage, prod)'
        required: false
        default: ''
      status:
        description: 'Status do deploy'
        required: true
        default: 'NÃ£o iniciado'

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      manifest_path: ${{ steps.detect.outputs.manifest_path }}
    steps:
      - name: Detect Environment based on branch and input
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            case "${{ github.ref_name }}" in
              "develop") ENV="develop" ;;
              "stage") ENV="stage" ;;
              "prod") ENV="prod" ;;
              "main") ENV="prod" ;;
              *) ENV="develop" ;;
            esac
          fi

          MANIFEST_PATH="k8s/apps/${{ env.APP_NAME }}/$ENV"

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "manifest_path=$MANIFEST_PATH" >> $GITHUB_OUTPUT

          echo "ğŸ¯ Branch: ${{ github.ref_name }}"
          echo "ğŸ¯ Input environment: ${{ github.event.inputs.environment }}"
          echo "ğŸ¯ Ambiente detectado: $ENV"
          echo "ğŸ“ Path do manifest: $MANIFEST_PATH"

  build-and-push:
    runs-on: ubuntu-latest
    needs: detect-environment
    env:
      APP_NAME: "app-teste-2"
      APP_PORT: 9000
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
      MANIFEST_PATH: ${{ needs.detect-environment.outputs.manifest_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: ğŸ¯ Show Environment Info
        run: |
          echo "=========================================="
          echo "ğŸ¯ DEPLOY PARA: ${{ ENVIRONMENT }}"
          echo "ğŸŒ Branch: ${{ github.ref_name }}"
          echo "ğŸ“¦ AplicaÃ§Ã£o: ${APP_NAME}"
          echo "ğŸ“ Path do manifest: ${MANIFEST_PATH}"
          echo "=========================================="

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to OCIR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.OCIR_REGISTRY }}
          username: ${{ secrets.OCIR_USERNAME }}
          password: ${{ secrets.OCIR_AUTH_TOKEN }}

      - name: Build and push image dynamically based on environment
        run: |
          IMAGE="${{ secrets.OCIR_REGISTRY }}/${{ secrets.IMAGE_NAMESPACE }}/${ENVIRONMENT}/image/${APP_NAME}:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          echo "ğŸ¯ Ambiente: ${ENVIRONMENT}"
          echo "ğŸ—ï¸ Imagem: $IMAGE"
          if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
            echo "âœ… Imagem $IMAGE jÃ¡ existe"
          else
            echo "ğŸ“¦ Buildando e pushando $IMAGE..."
            docker build -t "$IMAGE" .
            docker push "$IMAGE"
          fi

      - name: Install Trivy
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh
          mkdir -p $HOME/bin
          mv ./bin/trivy $HOME/bin/
          echo "$HOME/bin" >> $GITHUB_PATH
          export PATH="$HOME/bin:$PATH"
          trivy --version

      - name: Criar diretÃ³rio para relatÃ³rio Trivy
        run: mkdir -p trivy-reports

      - name: Scan image with Trivy
        id: trivy
        run: |
          export PATH="$HOME/bin:$PATH"
          trivy image --severity HIGH,CRITICAL --exit-code 1 \
            --format json -o trivy-reports/trivy-report-${ENVIRONMENT}.json \
            "${IMAGE}"

      - name: Show Trivy JSON summary in log
        if: always()
        run: |
          echo "ğŸ” Resumo das vulnerabilidades HIGH/CRITICAL para ${ENVIRONMENT}:"
          if [ -f trivy-reports/trivy-report-${ENVIRONMENT}.json ]; then
            jq '.Results[]?.Vulnerabilities[]? | {PkgName, InstalledVersion, Severity, Title}' trivy-reports/trivy-report-${ENVIRONMENT}.json || echo "âœ… Nenhuma vulnerabilidade encontrada"
          else
            echo "âœ… RelatÃ³rio nÃ£o encontrado"
          fi

      - name: Upload Trivy report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report-${ENVIRONMENT}
          path: trivy-reports/trivy-report-${ENVIRONMENT}.json

      - name: Notify Teams on Trivy failure
        if: failure()
        run: |
          if [ -n "$TEAMS_WEBHOOK_URL" ]; then
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r '.artifacts[0].id')
            REPORT_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts/${ARTIFACT_ID}"
            PAYLOAD="{\"text\": \"âš ï¸ A pipeline falhou durante o scan do Trivy para '${APP_NAME}' no ambiente '${ENVIRONMENT}'.\\nğŸ”— RelatÃ³rio disponÃ­vel em: ${REPORT_URL}\"}"
            curl -H 'Content-Type: application/json' -d "$PAYLOAD" $TEAMS_WEBHOOK_URL
          fi
      - name: Update Fleet repo manifests dynamically
        if: success()
        env:
          FLEET_REPO: ${{ secrets.FLEET_REPO_URL }}
          FLEET_PAT: ${{ secrets.FLEET_REPO_PAT }}
          IMAGE: ${{ env.IMAGE }}
          PORT: ${{ env.APP_PORT }}
          APP_NAME: ${{ needs.detect-environment.outputs.app_name }}
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
        run: |
          set -euo pipefail

          echo "ğŸš€ Atualizando manifests para ambiente: ${ENVIRONMENT}"
          echo "ğŸ“ App: ${APP_NAME}"
          echo "ğŸ¯ Imagem: ${IMAGE}"
          echo "ğŸ”Œ Porta: ${PORT}"

          # Sanitiza variÃ¡veis
          CLEAN_ENVIRONMENT=$(echo "${ENVIRONMENT}" | tr -d '/' | tr -d '\\')
          CLEAN_APP_NAME=$(echo "${APP_NAME}" | tr -d '/' | tr -d '\\')

          # Corrige o path do manifest
          MANIFEST_PATH="k8s/apps/${CLEAN_APP_NAME}/${CLEAN_ENVIRONMENT}"
          DEPLOYMENT_MANIFEST="${MANIFEST_PATH}/deployment.yaml"
          SERVICE_MANIFEST="${MANIFEST_PATH}/service.yaml"

          echo "ğŸ“ Path correto do manifest: ${MANIFEST_PATH}"

          # ConfiguraÃ§Ã£o git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Clone do repositÃ³rio fleet
          REPO_NO_PROTO="${FLEET_REPO#https://}"
          CLONE_URL="https://${FLEET_PAT}@${REPO_NO_PROTO}"

          echo "ğŸ” Clonando repositÃ³rio fleet..."
          rm -rf fleet-repo

          if ! git clone "${CLONE_URL}" fleet-repo; then
            echo "âŒ Falha ao clonar repositÃ³rio"
            exit 1
          fi

          cd fleet-repo

          # Lista branches para debug
          echo "ğŸŒ¿ Branches disponÃ­veis:"
          git branch -a

          git fetch --all

          # Define branch de base caso nÃ£o exista
          BASE_BRANCH=""
          for b in main master develop; do
            if git ls-remote --heads origin "$b" | grep -q "$b"; then
              BASE_BRANCH="$b"
              break
            fi
          done

          if [ -z "$BASE_BRANCH" ]; then
            echo "âš ï¸ Nenhuma branch base encontrada. Criando branch inicial 'main'"
            git checkout --orphan main
            git commit --allow-empty -m "Init repo"
            git push origin main
            BASE_BRANCH="main"
          fi

          # Checkout ou criaÃ§Ã£o da branch do ambiente
          if git ls-remote --heads origin "${CLEAN_ENVIRONMENT}" | grep -q "${CLEAN_ENVIRONMENT}"; then
            echo "âœ… Branch ${CLEAN_ENVIRONMENT} encontrada"
            git checkout -b "${CLEAN_ENVIRONMENT}" "origin/${CLEAN_ENVIRONMENT}" 2>/dev/null || git checkout "${CLEAN_ENVIRONMENT}"
          else
            echo "âš ï¸ Branch ${CLEAN_ENVIRONMENT} nÃ£o encontrada, criando nova a partir de ${BASE_BRANCH}"
            git checkout -b "${CLEAN_ENVIRONMENT}" "origin/${BASE_BRANCH}"
          fi

          echo "ğŸ“ Branch atual: $(git branch --show-current)"

          # Cria diretÃ³rio se nÃ£o existir
          mkdir -p "${MANIFEST_PATH}"

          # Cria ou sobrescreve deployment.yaml
          echo "ğŸ“ Criando deployment.yaml..."
          cat > "${DEPLOYMENT_MANIFEST}" << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${CLEAN_APP_NAME}-${CLEAN_ENVIRONMENT}
            namespace: ${CLEAN_ENVIRONMENT}
            labels:
              app: ${CLEAN_APP_NAME}
              env: ${CLEAN_ENVIRONMENT}
            annotations:
              fleet.cattle.io/auto-update-image: "true"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: ${CLEAN_APP_NAME}
                env: ${CLEAN_ENVIRONMENT}
            template:
              metadata:
                labels:
                  app: ${CLEAN_APP_NAME}
                  env: ${CLEAN_ENVIRONMENT}
              spec:
                containers:
                  - name: ${CLEAN_APP_NAME}
                    image: ${IMAGE}
                    imagePullPolicy: Always
                    ports:
                      - containerPort: ${PORT}
                    readinessProbe:
                      httpGet:
                        path: /
                        port: ${PORT}
                      initialDelaySeconds: 5
                      periodSeconds: 10
                imagePullSecrets:
                  - name: ocir-regcred
          EOF

              # Cria ou sobrescreve service.yaml
              echo "ğŸ“ Criando service.yaml..."
              NODE_PORT_HASH=$(echo "${CLEAN_APP_NAME}-${CLEAN_ENVIRONMENT}" | md5sum | cut -c1-4)
              NODE_PORT=$((30000 + 0x${NODE_PORT_HASH} % 2768))
              cat > "${SERVICE_MANIFEST}" << EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: ${CLEAN_APP_NAME}-svc
            namespace: ${CLEAN_ENVIRONMENT}
          spec:
            selector:
              app: ${CLEAN_APP_NAME}
            ports:
              - port: 80
                targetPort: ${PORT}
                nodePort: ${NODE_PORT}
                protocol: TCP
            type: NodePort
          EOF

              echo "âœ… Manifests criados!"
              echo "   Deployment: ${DEPLOYMENT_MANIFEST}"
              echo "   Service: ${SERVICE_MANIFEST}"
              echo "   NodePort: ${NODE_PORT}"

              # Commit e push se houver alteraÃ§Ãµes
              if git diff --quiet --exit-code; then
                echo "â„¹ï¸ Nenhuma alteraÃ§Ã£o detectada nos manifests"
              else
                echo "ğŸ“ Commitando alteraÃ§Ãµes..."
                git add "${MANIFEST_PATH}/"
                git commit -m "ğŸš€ Deploy ${CLEAN_APP_NAME} para ${CLEAN_ENVIRONMENT}: ${IMAGE}

          - Imagem: ${IMAGE}
          - Porta: ${PORT}
          - NodePort: ${NODE_PORT}
          - Timestamp: $(date -u)

          [ci skip]"
                git push -u origin "${CLEAN_ENVIRONMENT}"
                echo "âœ… Manifests atualizados com sucesso!"
              fi

              echo "ğŸ‰ Deploy finalizado!"

      - name: Create/Update Monday Item
        if: success()
        env:
          MONDAY_API_TOKEN: ${{ secrets.MONDAY_API_TOKEN }}
          APP_NAME: ${{ env.APP_NAME }}
          IMAGE: ${{ env.IMAGE }}
          BOARD_ID: "10018892855"
        run: |
          set -eo pipefail
          ITEM_NAME="Deploy ${ENVIRONMENT} - $APP_NAME"
          IMAGE_INFO="Env: ${ENVIRONMENT} | Imagem: $IMAGE"
          echo "ğŸš€ Verificando item: $ITEM_NAME"

          QUERY=$(jq -n --arg board_id "$BOARD_ID" \
            '{query: "query { boards(ids: [\($board_id)]) { items_page { items { id name column_values { id text } } } } }"}')

          RESPONSE=$(curl -s -X POST https://api.monday.com/v2 \
            -H "Authorization: Bearer $MONDAY_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data-raw "$QUERY")

          if echo "$RESPONSE" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
            echo "ğŸš« Erro da API do Monday. Aborting."
            echo "$RESPONSE" | jq .
            exit 1
          fi

          ITEM_ID=$(echo "$RESPONSE" | jq -r --arg name "$ITEM_NAME" \
            '.data.boards[0].items_page.items[]? | select(.name == $name) | .id // empty')
          CURRENT_STATUS=$(echo "$RESPONSE" | jq -r --arg name "$ITEM_NAME" \
            '.data.boards[0].items_page.items[]? | select(.name == $name) | (.column_values? // []) | map(select(.id=="project_status"))[0].text // empty')

          echo "ITEM_ID=${ITEM_ID:-<empty>}"
          echo "CURRENT_STATUS=${CURRENT_STATUS:-<empty>}"

          if [ -z "$ITEM_ID" ]; then
            echo "â• Criando item para ambiente ${ENVIRONMENT}..."
            case "$ENVIRONMENT" in
              "develop") INITIAL_STATUS="Para Teste" ;;
              "stage") INITIAL_STATUS="Para Teste" ;;
              "prod") INITIAL_STATUS="Aprovado para Prod" ;;
              *) INITIAL_STATUS="NÃ£o iniciado" ;;
            esac

            COLUMN_VALUES=$(jq -n --arg info "$IMAGE_INFO" --arg status "$INITIAL_STATUS" \
              '{project_status: {label: $status}, text_mkvn9dqm: $info}')
            COLUMN_VALUES_ESCAPED=$(echo "$COLUMN_VALUES" | jq -Rs .)
            PAYLOAD=$(jq -n --arg name "$ITEM_NAME" --arg board_id "$BOARD_ID" --arg colvals "$COLUMN_VALUES_ESCAPED" \
              '{query: "mutation { create_item(board_id: \($board_id|tonumber), item_name: \"\($name)\", column_values: \($colvals)) { id name } }"}')

            CREATE_RESP=$(curl -s -X POST https://api.monday.com/v2 \
              -H "Authorization: Bearer $MONDAY_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data-raw "$PAYLOAD")

            if echo "$CREATE_RESP" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
              echo "ğŸš« Erro ao criar item no Monday."
              echo "$CREATE_RESP" | jq .
              exit 1
            fi
            echo "âœ… Item criado com sucesso para ${ENVIRONMENT}!"
          else
            echo "ğŸ”„ Atualizando item existente para ${ENVIRONMENT}..."
            IMAGE_ESCAPED=$(echo "$IMAGE_INFO" | jq -Rs .)
            UPDATE_PAYLOAD=$(jq -n --arg item_id "$ITEM_ID" --arg board_id "$BOARD_ID" --arg info "$IMAGE_ESCAPED" \
              '{query: "mutation { change_simple_column_value(board_id: \($board_id|tonumber), item_id: \($item_id|tonumber), column_id: \"text_mkvn9dqm\", value: \($info)) { id } }"}')

            UPDATE_RESP=$(curl -s -X POST https://api.monday.com/v2 \
              -H "Authorization: Bearer $MONDAY_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data-raw "$UPDATE_PAYLOAD")

            if echo "$UPDATE_RESP" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
              echo "ğŸš« Erro ao atualizar item no Monday."
              echo "$UPDATE_RESP" | jq .
              exit 1
            fi
            echo "âœ… Item atualizado com sucesso para ${ENVIRONMENT}!"
          fi

      - name: ğŸ‰ Deploy Summary
        if: always()
        run: |
          echo "=========================================="
          echo "ğŸ‰ DEPLOY FINALIZADO"
          echo "=========================================="
          echo "ğŸ¯ AMBIENTE: ${ENVIRONMENT^^}"
          echo "ğŸŒ BRANCH: ${{ github.ref_name }}"
          echo "ğŸ—ï¸ AplicaÃ§Ã£o: ${APP_NAME}"
          echo "ğŸ¨ Imagem: ${IMAGE}"
          echo "ğŸ“ Manifests: ${MANIFEST_PATH}"
          echo "ğŸŒ Porta: ${APP_PORT}"
          echo "ğŸ“Š Status: ${{ job.status }}"
