name: Deploy Multi-Environment

on:
  push:
    branches: [ "develop", "stage", "prod" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente de deploy (develop, stage, prod)'
        required: false
        default: ''
      status:
        description: 'Status do deploy'
        required: true
        default: 'Não iniciado'

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      manifest_path: ${{ steps.detect.outputs.manifest_path }}
    steps:
      - name: Detect Environment based on branch and input
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            case "${{ github.ref_name }}" in
              "develop") ENV="develop" ;;
              "stage") ENV="stage" ;;
              "prod") ENV="prod" ;;
              "main") ENV="prod" ;;
              *) ENV="develop" ;;
            esac
          fi

          MANIFEST_PATH="k8s/apps/${{ env.APP_NAME }}/$ENV"

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "manifest_path=$MANIFEST_PATH" >> $GITHUB_OUTPUT

          echo "🎯 Branch: ${{ github.ref_name }}"
          echo "🎯 Input environment: ${{ github.event.inputs.environment }}"
          echo "🎯 Ambiente detectado: $ENV"
          echo "📁 Path do manifest: $MANIFEST_PATH"

  build-and-push:
    runs-on: ubuntu-latest
    needs: detect-environment
    env:
      APP_NAME: "app-teste-2"
      APP_PORT: 9000
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
      MANIFEST_PATH: ${{ needs.detect-environment.outputs.manifest_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: 🎯 Show Environment Info
        run: |
          echo "=========================================="
          echo "🎯 DEPLOY PARA: ${{ ENVIRONMENT }}"
          echo "🌐 Branch: ${{ github.ref_name }}"
          echo "📦 Aplicação: ${APP_NAME}"
          echo "📁 Path do manifest: ${MANIFEST_PATH}"
          echo "=========================================="

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to OCIR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.OCIR_REGISTRY }}
          username: ${{ secrets.OCIR_USERNAME }}
          password: ${{ secrets.OCIR_AUTH_TOKEN }}

      - name: Build and push image dynamically based on environment
        run: |
          IMAGE="${{ secrets.OCIR_REGISTRY }}/${{ secrets.IMAGE_NAMESPACE }}/${ENVIRONMENT}/image/${APP_NAME}:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          echo "🎯 Ambiente: ${ENVIRONMENT}"
          echo "🏗️ Imagem: $IMAGE"
          if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
            echo "✅ Imagem $IMAGE já existe"
          else
            echo "📦 Buildando e pushando $IMAGE..."
            docker build -t "$IMAGE" .
            docker push "$IMAGE"
          fi

      - name: Install Trivy
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh
          mkdir -p $HOME/bin
          mv ./bin/trivy $HOME/bin/
          echo "$HOME/bin" >> $GITHUB_PATH
          export PATH="$HOME/bin:$PATH"
          trivy --version

      - name: Criar diretório para relatório Trivy
        run: mkdir -p trivy-reports

      - name: Scan image with Trivy
        id: trivy
        run: |
          export PATH="$HOME/bin:$PATH"
          trivy image --severity HIGH,CRITICAL --exit-code 1 \
            --format json -o trivy-reports/trivy-report-${ENVIRONMENT}.json \
            "${IMAGE}"

      - name: Show Trivy JSON summary in log
        if: always()
        run: |
          echo "🔍 Resumo das vulnerabilidades HIGH/CRITICAL para ${ENVIRONMENT}:"
          if [ -f trivy-reports/trivy-report-${ENVIRONMENT}.json ]; then
            jq '.Results[]?.Vulnerabilities[]? | {PkgName, InstalledVersion, Severity, Title}' trivy-reports/trivy-report-${ENVIRONMENT}.json || echo "✅ Nenhuma vulnerabilidade encontrada"
          else
            echo "✅ Relatório não encontrado"
          fi

      - name: Upload Trivy report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report-${ENVIRONMENT}
          path: trivy-reports/trivy-report-${ENVIRONMENT}.json

      - name: Notify Teams on Trivy failure
        if: failure()
        run: |
          if [ -n "$TEAMS_WEBHOOK_URL" ]; then
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r '.artifacts[0].id')
            REPORT_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts/${ARTIFACT_ID}"
            PAYLOAD="{\"text\": \"⚠️ A pipeline falhou durante o scan do Trivy para '${APP_NAME}' no ambiente '${ENVIRONMENT}'.\\n🔗 Relatório disponível em: ${REPORT_URL}\"}"
            curl -H 'Content-Type: application/json' -d "$PAYLOAD" $TEAMS_WEBHOOK_URL
          fi
      - name: Update Fleet repo manifests dynamically
        if: success()
        env:
          FLEET_REPO: ${{ secrets.FLEET_REPO_URL }}
          FLEET_BRANCH: ${{ needs.detect-environment.outputs.environment }}
          FLEET_PAT: ${{ secrets.FLEET_REPO_PAT }}
          IMAGE: ${{ env.IMAGE }}
          PORT: ${{ env.APP_PORT }}
          APP_NAME: "app-teste-2"
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
        run: |
          set -euo pipefail

          echo "🚀 Atualizando manifests para ambiente: ${ENVIRONMENT}"
          echo "🎯 Imagem: ${IMAGE}"
          echo "📦 App: ${APP_NAME}"
          echo "🌿 Branch: ${FLEET_BRANCH}"
          echo "🏠 Repo: ${FLEET_REPO}"

          # Validações básicas
          if [ -z "${FLEET_REPO}" ]; then
            echo "❌ FLEET_REPO não definido"
            exit 1
          fi

          if [ -z "${FLEET_PAT}" ]; then
            echo "❌ FLEET_PAT não definido"
            exit 1
          fi

          if [ -z "${FLEET_BRANCH}" ]; then
            echo "❌ FLEET_BRANCH não definido"
            exit 1
          fi

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Constrói URL com token
          REPO_NO_PROTO="${FLEET_REPO#https://}"
          CLONE_URL="https://${FLEET_PAT}@${REPO_NO_PROTO}"
          BRANCH="${FLEET_BRANCH}"

          echo "🔍 Debug - Branch a ser verificada: '${BRANCH}'"
          echo "🔍 Debug - Repo URL (sem token): ${FLEET_REPO}"

          # Testa conectividade primeiro
          echo "🔗 Testando conectividade com o repositório..."
          if ! git ls-remote --heads "${CLONE_URL}" > /dev/null 2>&1; then
            echo "❌ Falha na conectividade com o repositório"
            echo "Verifique se o token PAT tem as permissões corretas"
            exit 1
          fi

          echo "✅ Conectividade OK. Listando branches remotas:"
          git ls-remote --heads "${CLONE_URL}" | sed 's|refs/heads/||' | while read commit branch; do
            echo "  📍 ${branch}"
          done

          # Verifica se a branch específica existe
          echo "🔍 Verificando se branch '${BRANCH}' existe remotamente..."
          
          # Método mais robusto para verificar branch
          BRANCH_EXISTS=$(git ls-remote --heads "${CLONE_URL}" "${BRANCH}" | wc -l)
          
          if [ "${BRANCH_EXISTS}" -gt 0 ]; then
            echo "✅ Branch '${BRANCH}' encontrada! Clonando diretamente..."
            git clone --branch "${BRANCH}" --single-branch "${CLONE_URL}" fleet-repo
            cd fleet-repo
            echo "📍 Branch atual: $(git branch --show-current)"
          else
            echo "⚠️ Branch '${BRANCH}' não encontrada. Branches disponíveis:"
            git ls-remote --heads "${CLONE_URL}" | sed 's|refs/heads/||' | awk '{print "  - " $2}'
            
            echo "🔧 Criando nova branch a partir de develop/main..."
            git clone "${CLONE_URL}" fleet-repo
            cd fleet-repo
            
            # Lista branches locais disponíveis
            echo "📍 Branches locais disponíveis:"
            git branch -a
            
            # Estratégia de fallback melhorada
            if git show-ref --verify --quiet refs/remotes/origin/develop; then
              echo "✅ Usando develop como base"
              git checkout -b "${BRANCH}" origin/develop
            elif git show-ref --verify --quiet refs/remotes/origin/main; then
              echo "✅ Usando main como base"
              git checkout -b "${BRANCH}" origin/main
            elif git show-ref --verify --quiet refs/remotes/origin/master; then
              echo "✅ Usando master como base"
              git checkout -b "${BRANCH}" origin/master
            else
              echo "⚠️ Usando branch padrão"
              DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
              git checkout -b "${BRANCH}" "origin/${DEFAULT_BRANCH}"
            fi
            
            echo "📍 Nova branch criada: $(git branch --show-current)"
          fi

          # Instala yq se não estiver disponível
          if ! command -v yq &> /dev/null; then
            echo "📦 Instalando yq..."
            sudo apt-get update -qq
            sudo apt-get install -y -qq jq
            
            # Download com retry
            for i in {1..3}; do
              if curl -sSL https://github.com/mikefarah/yq/releases/download/v4.45.1/yq_linux_amd64 -o yq; then
                chmod +x yq
                sudo mv yq /usr/local/bin/
                break
              else
                echo "⚠️ Tentativa ${i} de download do yq falhou"
                sleep 2
              fi
            done
            
            if ! command -v yq &> /dev/null; then
              echo "❌ Falha na instalação do yq"
              exit 1
            fi
          fi

          echo "✅ yq versão: $(yq --version)"

          # Define paths dentro do repo
          MANIFEST_PATH="k8s/apps/${APP_NAME}/${ENVIRONMENT}"
          DEPLOYMENT_MANIFEST="${MANIFEST_PATH}/deployment.yaml"
          SERVICE_MANIFEST="${MANIFEST_PATH}/service.yaml"

          echo "📁 Path dos manifests: ${MANIFEST_PATH}"
          echo "📝 Deployment: ${DEPLOYMENT_MANIFEST}"
          echo "🔧 Service: ${SERVICE_MANIFEST}"

          # Cria diretório
          mkdir -p "$MANIFEST_PATH"

          # Cria template do deployment se não existir
          if [ ! -f "$DEPLOYMENT_MANIFEST" ]; then
            echo "📝 Criando deployment.yaml..."
            cat > "$DEPLOYMENT_MANIFEST" << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${APP_NAME}-${ENVIRONMENT}
            namespace: ${ENVIRONMENT}
            labels:
              app: ${APP_NAME}
              environment: ${ENVIRONMENT}
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: ${APP_NAME}
                environment: ${ENVIRONMENT}
            template:
              metadata:
                labels:
                  app: ${APP_NAME}
                  environment: ${ENVIRONMENT}
              spec:
                containers:
                - name: ${APP_NAME}
                  image: ${IMAGE}
                  ports:
                  - containerPort: ${PORT}
                  env:
                  - name: ENVIRONMENT
                    value: ${ENVIRONMENT}
                  - name: APP_PORT
                    value: "${PORT}"
          EOF
              else
                echo "✅ deployment.yaml já existe"
              fi

              # Cria template do service se não existir
              if [ ! -f "$SERVICE_MANIFEST" ]; then
                echo "📝 Criando service.yaml..."
                cat > "$SERVICE_MANIFEST" << EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: ${APP_NAME}-${ENVIRONMENT}-service
            namespace: ${ENVIRONMENT}
            labels:
              app: ${APP_NAME}
              environment: ${ENVIRONMENT}
          spec:
            selector:
              app: ${APP_NAME}
              environment: ${ENVIRONMENT}
            ports:
            - protocol: TCP
              port: 80
              targetPort: ${PORT}
            type: ClusterIP
          EOF
              else
                echo "✅ service.yaml já existe"
              fi

              # Atualiza manifests existentes
              echo "🔄 Atualizando manifests com nova imagem..."
              echo "  🎯 Nova imagem: ${IMAGE}"
              echo "  🔌 Nova porta: ${PORT}"

              # Backup dos arquivos antes da modificação
              cp "$DEPLOYMENT_MANIFEST" "${DEPLOYMENT_MANIFEST}.backup"
              cp "$SERVICE_MANIFEST" "${SERVICE_MANIFEST}.backup"

              # Aplica atualizações com verificação
              if yq e -i ".spec.template.spec.containers[0].image = \"${IMAGE}\"" "$DEPLOYMENT_MANIFEST"; then
                echo "  ✅ Imagem atualizada no deployment"
              else
                echo "  ❌ Erro ao atualizar imagem no deployment"
                exit 1
              fi

              if yq e -i ".spec.template.spec.containers[0].ports[0].containerPort = ${PORT}" "$DEPLOYMENT_MANIFEST"; then
                echo "  ✅ Porta do container atualizada"
              else
                echo "  ❌ Erro ao atualizar porta do container"
                exit 1
              fi

              if yq e -i ".spec.template.spec.containers[0].env[1].value = \"${PORT}\"" "$DEPLOYMENT_MANIFEST"; then
                echo "  ✅ Variável de ambiente APP_PORT atualizada"
              else
                echo "  ⚠️ Aviso: Não foi possível atualizar APP_PORT (pode não existir)"
              fi

              if yq e -i ".spec.ports[0].targetPort = ${PORT}" "$SERVICE_MANIFEST"; then
                echo "  ✅ Target port do service atualizada"
              else
                echo "  ❌ Erro ao atualizar target port do service"
                exit 1
              fi

              # Mostra diff das alterações
              echo "📋 Resumo das alterações:"
              if git diff --name-only | grep -q .; then
                git diff --name-only | while read file; do
                  echo "  📝 Modificado: ${file}"
                done
                
                echo "🔍 Detalhes das alterações:"
                git diff --color=never | head -50
              else
                echo "  ✅ Nenhuma alteração detectada"
              fi

              # Commit e push
              if git diff --quiet --exit-code; then
                echo "✅ Nenhuma alteração detectada nos manifests"
              else
                echo "💾 Commitando alterações..."
                git add "$MANIFEST_PATH/"
                
                # Commit com informações detalhadas
                COMMIT_MSG="Deploy ${APP_NAME} para ${ENVIRONMENT}

          - Imagem: ${IMAGE}
          - Porta: ${PORT}
          - Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          [ci skip]"
                
                git commit -m "${COMMIT_MSG}"
                
                echo "🚀 Fazendo push para origin/${BRANCH}..."
                git push origin "${BRANCH}"
                echo "✅ Manifests atualizados com sucesso!"
                
                # Mostra o commit criado
                echo "📋 Commit criado:"
                git log -1 --oneline
              fi

          echo "🎉 Deploy finalizado com sucesso!"

      - name: Create/Update Monday Item
        if: success()
        env:
          MONDAY_API_TOKEN: ${{ secrets.MONDAY_API_TOKEN }}
          APP_NAME: ${{ env.APP_NAME }}
          IMAGE: ${{ env.IMAGE }}
          BOARD_ID: "10018892855"
        run: |
          set -eo pipefail
          ITEM_NAME="Deploy ${ENVIRONMENT} - $APP_NAME"
          IMAGE_INFO="Env: ${ENVIRONMENT} | Imagem: $IMAGE"
          echo "🚀 Verificando item: $ITEM_NAME"

          QUERY=$(jq -n --arg board_id "$BOARD_ID" \
            '{query: "query { boards(ids: [\($board_id)]) { items_page { items { id name column_values { id text } } } } }"}')

          RESPONSE=$(curl -s -X POST https://api.monday.com/v2 \
            -H "Authorization: Bearer $MONDAY_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data-raw "$QUERY")

          if echo "$RESPONSE" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
            echo "🚫 Erro da API do Monday. Aborting."
            echo "$RESPONSE" | jq .
            exit 1
          fi

          ITEM_ID=$(echo "$RESPONSE" | jq -r --arg name "$ITEM_NAME" \
            '.data.boards[0].items_page.items[]? | select(.name == $name) | .id // empty')
          CURRENT_STATUS=$(echo "$RESPONSE" | jq -r --arg name "$ITEM_NAME" \
            '.data.boards[0].items_page.items[]? | select(.name == $name) | (.column_values? // []) | map(select(.id=="project_status"))[0].text // empty')

          echo "ITEM_ID=${ITEM_ID:-<empty>}"
          echo "CURRENT_STATUS=${CURRENT_STATUS:-<empty>}"

          if [ -z "$ITEM_ID" ]; then
            echo "➕ Criando item para ambiente ${ENVIRONMENT}..."
            case "$ENVIRONMENT" in
              "develop") INITIAL_STATUS="Para Teste" ;;
              "stage") INITIAL_STATUS="Para Teste" ;;
              "prod") INITIAL_STATUS="Aprovado para Prod" ;;
              *) INITIAL_STATUS="Não iniciado" ;;
            esac

            COLUMN_VALUES=$(jq -n --arg info "$IMAGE_INFO" --arg status "$INITIAL_STATUS" \
              '{project_status: {label: $status}, text_mkvn9dqm: $info}')
            COLUMN_VALUES_ESCAPED=$(echo "$COLUMN_VALUES" | jq -Rs .)
            PAYLOAD=$(jq -n --arg name "$ITEM_NAME" --arg board_id "$BOARD_ID" --arg colvals "$COLUMN_VALUES_ESCAPED" \
              '{query: "mutation { create_item(board_id: \($board_id|tonumber), item_name: \"\($name)\", column_values: \($colvals)) { id name } }"}')

            CREATE_RESP=$(curl -s -X POST https://api.monday.com/v2 \
              -H "Authorization: Bearer $MONDAY_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data-raw "$PAYLOAD")

            if echo "$CREATE_RESP" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
              echo "🚫 Erro ao criar item no Monday."
              echo "$CREATE_RESP" | jq .
              exit 1
            fi
            echo "✅ Item criado com sucesso para ${ENVIRONMENT}!"
          else
            echo "🔄 Atualizando item existente para ${ENVIRONMENT}..."
            IMAGE_ESCAPED=$(echo "$IMAGE_INFO" | jq -Rs .)
            UPDATE_PAYLOAD=$(jq -n --arg item_id "$ITEM_ID" --arg board_id "$BOARD_ID" --arg info "$IMAGE_ESCAPED" \
              '{query: "mutation { change_simple_column_value(board_id: \($board_id|tonumber), item_id: \($item_id|tonumber), column_id: \"text_mkvn9dqm\", value: \($info)) { id } }"}')

            UPDATE_RESP=$(curl -s -X POST https://api.monday.com/v2 \
              -H "Authorization: Bearer $MONDAY_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data-raw "$UPDATE_PAYLOAD")

            if echo "$UPDATE_RESP" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
              echo "🚫 Erro ao atualizar item no Monday."
              echo "$UPDATE_RESP" | jq .
              exit 1
            fi
            echo "✅ Item atualizado com sucesso para ${ENVIRONMENT}!"
          fi

      - name: 🎉 Deploy Summary
        if: always()
        run: |
          echo "=========================================="
          echo "🎉 DEPLOY FINALIZADO"
          echo "=========================================="
          echo "🎯 AMBIENTE: ${ENVIRONMENT^^}"
          echo "🌐 BRANCH: ${{ github.ref_name }}"
          echo "🏗️ Aplicação: ${APP_NAME}"
          echo "🎨 Imagem: ${IMAGE}"
          echo "📁 Manifests: ${MANIFEST_PATH}"
          echo "🌐 Porta: ${APP_PORT}"
          echo "📊 Status: ${{ job.status }}"
