name: Deploy Multi-Environment

on:
  push:
    branches: [ "develop", "stage", "prod" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente de deploy (develop, stage, prod)'
        required: false
        default: ''
      status:
        description: 'Status do deploy'
        required: true
        default: 'NÃ£o iniciado'

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      manifest_path: ${{ steps.detect.outputs.manifest_path }}
    steps:
      - name: Detect Environment based on branch and input
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            case "${{ github.ref_name }}" in
              "develop") ENV="develop" ;;
              "stage") ENV="stage" ;;
              "prod"|"main") ENV="prod" ;;
              *) ENV="develop" ;;
            esac
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "manifest_path=k8s/apps/\${{ env.APP_NAME }}/$ENV" >> $GITHUB_OUTPUT

          # Define tÃ­tulo do workflow
          case "$ENV" in
            "develop") WORKFLOW_TITLE="ðŸš€ Deploy Development" ;;
            "stage") WORKFLOW_TITLE="ðŸ”„ Deploy Staging" ;;
            "prod") WORKFLOW_TITLE="ðŸŽ¯ Deploy Production" ;;
            *) WORKFLOW_TITLE="ðŸ”§ Deploy $ENV" ;;
          esac
          echo "workflow_title=$WORKFLOW_TITLE" >> $GITHUB_OUTPUT

      - name: Set Deploy URL
        run: |
          case "${{ steps.detect.outputs.environment }}" in
            develop) DEPLOY_URL="https://develop.example.com/${{ env.APP_NAME }}" ;;
            stage)   DEPLOY_URL="https://stage.example.com/${{ env.APP_NAME }}" ;;
            prod)    DEPLOY_URL="https://www.example.com/${{ env.APP_NAME }}" ;;
            *)       DEPLOY_URL="https://develop.example.com/${{ env.APP_NAME }}" ;;
          esac
          echo "DEPLOY_URL=${DEPLOY_URL}" >> $GITHUB_ENV
          echo "ðŸŒ Deploy URL: ${DEPLOY_URL}"

  build-and-push:
    runs-on: ubuntu-latest
    needs: detect-environment
    env:
      APP_NAME: "app-teste-2"
      APP_PORT: 9000
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
      DEPLOY_URL: ${{ env.DEPLOY_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: ðŸŽ¯ Show Environment Info
        run: |
          echo "=========================================="
          echo "ðŸŽ¯ DEPLOY PARA: ${{ needs.detect-environment.outputs.environment }}"
          echo "ðŸŒ Branch: ${{ github.ref_name }}"
          echo "ðŸ“¦ AplicaÃ§Ã£o: ${APP_NAME}"
          echo "ðŸŒ URL: ${DEPLOY_URL}"
          echo "=========================================="

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to OCIR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.OCIR_REGISTRY }}
          username: ${{ secrets.OCIR_USERNAME }}
          password: ${{ secrets.OCIR_AUTH_TOKEN }}

      - name: Build and push image dynamically based on environment
        run: |
          IMAGE="${{ secrets.OCIR_REGISTRY }}/${{ secrets.IMAGE_NAMESPACE }}/${ENVIRONMENT}/image/${APP_NAME}:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          echo "ðŸŽ¯ Ambiente: ${ENVIRONMENT}"
          echo "ðŸ—ï¸ Imagem: $IMAGE"
          if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
            echo "âœ… Imagem $IMAGE jÃ¡ existe"
          else
            docker build -t "$IMAGE" .
            docker push "$IMAGE"
          fi

      - name: Update Fleet repo manifests dynamically
        env:
          FLEET_REPO: ${{ secrets.FLEET_REPO_URL }}
          FLEET_BRANCH: ${{ env.ENVIRONMENT }}
          FLEET_PAT: ${{ secrets.FLEET_REPO_PAT }}
          IMAGE: ${{ env.IMAGE }}
          PORT: ${{ env.APP_PORT }}
          MANIFEST_PATH: ${{ needs.detect-environment.outputs.manifest_path }}
          DEPLOY_URL: ${{ env.DEPLOY_URL }}
        run: |
          set -euo pipefail
          REPO_NO_PROTO="${FLEET_REPO#https://}"
          CLONE_URL="https://${FLEET_PAT}@${REPO_NO_PROTO}"
          BRANCH="${FLEET_BRANCH}"

          if git ls-remote --heads "${CLONE_URL}" "${BRANCH}" | grep "${BRANCH}" >/dev/null; then
            git clone --depth 1 --branch "${BRANCH}" "${CLONE_URL}" fleet-repo
          else
            git clone --depth 1 --branch develop "${CLONE_URL}" fleet-repo
            cd fleet-repo
            git checkout -b "${BRANCH}"
            git push origin "${BRANCH}"
            cd ..
          fi

          cd fleet-repo
          sudo apt-get update -qq
          sudo apt-get install -y -qq jq
          curl -sSL https://github.com/mikefarah/yq/releases/download/v4.45.1/yq_linux_amd64 -o yq
          chmod +x yq
          sudo mv yq /usr/local/bin/

          DEPLOYMENT_MANIFEST="${MANIFEST_PATH}/deployment.yaml"
          SERVICE_MANIFEST="${MANIFEST_PATH}/service.yaml"
          mkdir -p "$(dirname "$DEPLOYMENT_MANIFEST")"

          if [ ! -f "$DEPLOYMENT_MANIFEST" ]; then
            cat > "$DEPLOYMENT_MANIFEST" << EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: ${APP_NAME}-${ENVIRONMENT}
              namespace: ${ENVIRONMENT}
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: ${APP_NAME}
                  environment: ${ENVIRONMENT}
              template:
                metadata:
                  labels:
                    app: ${APP_NAME}
                    environment: ${ENVIRONMENT}
                spec:
                  containers:
                  - name: ${APP_NAME}
                    image: ${IMAGE}
                    ports:
                    - containerPort: ${PORT}
                    env:
                    - name: ENVIRONMENT
                      value: ${ENVIRONMENT}
                    - name: APP_PORT
                      value: "${PORT}"
                    - name: DEPLOY_URL
                      value: "${DEPLOY_URL}"
            EOF
                      fi

                      if [ ! -f "$SERVICE_MANIFEST" ]; then
                        cat > "$SERVICE_MANIFEST" << EOF
            apiVersion: v1
            kind: Service
            metadata:
              name: ${APP_NAME}-${ENVIRONMENT}-service
              namespace: ${ENVIRONMENT}
            spec:
              selector:
                app: ${APP_NAME}
                environment: ${ENVIRONMENT}
              ports:
              - protocol: TCP
                port: 80
                targetPort: ${PORT}
              type: ClusterIP
            EOF
                      fi

          # Atualiza manifests existentes
          yq e -i ".spec.template.spec.containers[0].image = \"${IMAGE}\"" "$DEPLOYMENT_MANIFEST"
          yq e -i ".spec.template.spec.containers[0].ports[0].containerPort = ${PORT}" "$DEPLOYMENT_MANIFEST"
          yq e -i ".spec.template.spec.containers[0].env[1].value = \"${PORT}\"" "$DEPLOYMENT_MANIFEST"
          yq e -i ".spec.template.spec.containers[0].env[2].value = \"${DEPLOY_URL}\"" "$DEPLOYMENT_MANIFEST"
          yq e -i ".spec.ports[0].targetPort = ${PORT}" "$SERVICE_MANIFEST"

          if git diff --quiet --exit-code; then
            echo "âœ… Nenhuma alteraÃ§Ã£o detectada nos manifests"
          else
            git add "${MANIFEST_PATH}/"
            git commit -m "Deploy ${APP_NAME} para ${ENVIRONMENT}: ${IMAGE} [ci skip]"
            git push origin "${BRANCH}"
            echo "âœ… Manifests atualizados com sucesso!"
          fi
