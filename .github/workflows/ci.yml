name: Deploy Multi-Environment

on:
  push:
    branches: [ "develop", "stage", "prod" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente de deploy (develop, stage, prod)'
        required: false
        default: ''
      status:
        description: 'Status do deploy'
        required: true
        default: 'N√£o iniciado'

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      manifest_path: ${{ steps.detect.outputs.manifest_path }}
    steps:
      - name: Detect Environment based on branch and input
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            case "${{ github.ref_name }}" in
              "develop") ENV="develop" ;;
              "stage") ENV="stage" ;;
              "prod") ENV="prod" ;;
              "main") ENV="prod" ;;
              *) ENV="develop" ;;
            esac
          fi

          MANIFEST_PATH="k8s/apps/${{ env.APP_NAME }}/$ENV"

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "manifest_path=$MANIFEST_PATH" >> $GITHUB_OUTPUT

          echo "üéØ Branch: ${{ github.ref_name }}"
          echo "üéØ Input environment: ${{ github.event.inputs.environment }}"
          echo "üéØ Ambiente detectado: $ENV"
          echo "üìÅ Path do manifest: $MANIFEST_PATH"

  build-and-push:
    runs-on: ubuntu-latest
    needs: detect-environment
    env:
      APP_NAME: "app-teste-2"
      APP_PORT: 9000
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
      MANIFEST_PATH: ${{ needs.detect-environment.outputs.manifest_path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: üéØ Show Environment Info
        run: |
          echo "=========================================="
          echo "üéØ DEPLOY PARA: ${{ ENVIRONMENT }}"
          echo "üåê Branch: ${{ github.ref_name }}"
          echo "üì¶ Aplica√ß√£o: ${APP_NAME}"
          echo "üìÅ Path do manifest: ${MANIFEST_PATH}"
          echo "=========================================="

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to OCIR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.OCIR_REGISTRY }}
          username: ${{ secrets.OCIR_USERNAME }}
          password: ${{ secrets.OCIR_AUTH_TOKEN }}

      - name: Build and push image dynamically based on environment
        run: |
          IMAGE="${{ secrets.OCIR_REGISTRY }}/${{ secrets.IMAGE_NAMESPACE }}/${ENVIRONMENT}/image/${APP_NAME}:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          echo "üéØ Ambiente: ${ENVIRONMENT}"
          echo "üèóÔ∏è Imagem: $IMAGE"
          if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
            echo "‚úÖ Imagem $IMAGE j√° existe"
          else
            echo "üì¶ Buildando e pushando $IMAGE..."
            docker build -t "$IMAGE" .
            docker push "$IMAGE"
          fi

      - name: Install Trivy
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh
          mkdir -p $HOME/bin
          mv ./bin/trivy $HOME/bin/
          echo "$HOME/bin" >> $GITHUB_PATH
          export PATH="$HOME/bin:$PATH"
          trivy --version

      - name: Criar diret√≥rio para relat√≥rio Trivy
        run: mkdir -p trivy-reports

      - name: Scan image with Trivy
        id: trivy
        run: |
          export PATH="$HOME/bin:$PATH"
          trivy image --severity HIGH,CRITICAL --exit-code 1 \
            --format json -o trivy-reports/trivy-report-${ENVIRONMENT}.json \
            "${IMAGE}"

      - name: Show Trivy JSON summary in log
        if: always()
        run: |
          echo "üîç Resumo das vulnerabilidades HIGH/CRITICAL para ${ENVIRONMENT}:"
          if [ -f trivy-reports/trivy-report-${ENVIRONMENT}.json ]; then
            jq '.Results[]?.Vulnerabilities[]? | {PkgName, InstalledVersion, Severity, Title}' trivy-reports/trivy-report-${ENVIRONMENT}.json || echo "‚úÖ Nenhuma vulnerabilidade encontrada"
          else
            echo "‚úÖ Relat√≥rio n√£o encontrado"
          fi

      - name: Upload Trivy report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report-${ENVIRONMENT}
          path: trivy-reports/trivy-report-${ENVIRONMENT}.json

      - name: Notify Teams on Trivy failure
        if: failure()
        run: |
          if [ -n "$TEAMS_WEBHOOK_URL" ]; then
            ARTIFACT_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" \
              | jq -r '.artifacts[0].id')
            REPORT_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts/${ARTIFACT_ID}"
            PAYLOAD="{\"text\": \"‚ö†Ô∏è A pipeline falhou durante o scan do Trivy para '${APP_NAME}' no ambiente '${ENVIRONMENT}'.\\nüîó Relat√≥rio dispon√≠vel em: ${REPORT_URL}\"}"
            curl -H 'Content-Type: application/json' -d "$PAYLOAD" $TEAMS_WEBHOOK_URL
          fi
      - name: Update Fleet repo manifests dynamically
        if: success()
        env:
          FLEET_REPO: ${{ secrets.FLEET_REPO_URL }}
          FLEET_BRANCH: ${{ needs.detect-environment.outputs.environment }}
          FLEET_PAT: ${{ secrets.FLEET_REPO_PAT }}
          IMAGE: ${{ env.IMAGE }}
          PORT: ${{ env.APP_PORT }}
          APP_NAME: "app-teste-2"
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
        run: |
          set -euo pipefail

          echo "üöÄ Atualizando manifests para ambiente: ${ENVIRONMENT}"
          echo "üéØ Imagem: ${IMAGE}"
          echo "üì¶ App: ${APP_NAME}"
          echo "üåø Branch: ${FLEET_BRANCH}"
          echo "üè† Repo: ${FLEET_REPO}"
          echo "üîå Porta: ${PORT}"

          # Valida√ß√µes b√°sicas
          if [ -z "${FLEET_REPO:-}" ]; then
            echo "‚ùå FLEET_REPO n√£o definido"
            exit 1
          fi

          if [ -z "${FLEET_PAT:-}" ]; then
            echo "‚ùå FLEET_PAT n√£o definido"
            exit 1
          fi

          if [ -z "${FLEET_BRANCH:-}" ]; then
            echo "‚ùå FLEET_BRANCH n√£o definido"
            exit 1
          fi

          if [ -z "${ENVIRONMENT:-}" ]; then
            echo "‚ùå ENVIRONMENT n√£o definido"
            exit 1
          fi

          # Sanitiza vari√°veis para evitar problemas de path
          CLEAN_APP_NAME=$(echo "${APP_NAME}" | sed 's/[^a-zA-Z0-9-]//g')
          CLEAN_ENVIRONMENT=$(echo "${ENVIRONMENT}" | sed 's/[^a-zA-Z0-9-]//g')
          CLEAN_BRANCH=$(echo "${FLEET_BRANCH}" | sed 's/[^a-zA-Z0-9-]//g')

          echo "üßπ Vari√°veis sanitizadas:"
          echo "  App: ${CLEAN_APP_NAME}"
          echo "  Environment: ${CLEAN_ENVIRONMENT}" 
          echo "  Branch: ${CLEAN_BRANCH}"

          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Constr√≥i URL com token
          REPO_NO_PROTO="${FLEET_REPO#https://}"
          CLONE_URL="https://${FLEET_PAT}@${REPO_NO_PROTO}"
          BRANCH="${CLEAN_BRANCH}"

          echo "üîó Testando conectividade com o reposit√≥rio..."
          # Testa conectividade primeiro (sem mostrar branches por seguran√ßa)
          if ! git ls-remote --heads "${CLONE_URL}" > /dev/null 2>&1; then
            echo "‚ùå Falha na conectividade com o reposit√≥rio"
            echo "Verifique se o token PAT tem as permiss√µes corretas"
            exit 1
          fi
          echo "‚úÖ Conectividade OK"

          # Lista branches dispon√≠veis (mascarando nomes sens√≠veis)
          echo "üåø Verificando branches dispon√≠veis..."
          AVAILABLE_BRANCHES=$(git ls-remote --heads "${CLONE_URL}" | sed 's|refs/heads/||' | awk '{print $2}')
          echo "Branches encontradas: $(echo "$AVAILABLE_BRANCHES" | wc -l)"

          # Verifica se a branch espec√≠fica existe
          echo "üîç Verificando se branch '${BRANCH}' existe..."
          
          if echo "$AVAILABLE_BRANCHES" | grep -q "^${BRANCH}$"; then
            echo "‚úÖ Branch '${BRANCH}' encontrada! Clonando..."
            git clone --branch "${BRANCH}" --depth 1 "${CLONE_URL}" fleet-repo
            cd fleet-repo
            echo "üìç Branch atual: $(git branch --show-current)"
          else
            echo "‚ö†Ô∏è Branch '${BRANCH}' n√£o encontrada."
            echo "üîß Criando nova branch..."
            
            git clone --depth 1 "${CLONE_URL}" fleet-repo
            cd fleet-repo
            
            # Verifica qual branch padr√£o usar como base
            if echo "$AVAILABLE_BRANCHES" | grep -q "^develop$"; then
              BASE_BRANCH="develop"
            elif echo "$AVAILABLE_BRANCHES" | grep -q "^main$"; then
              BASE_BRANCH="main"
            elif echo "$AVAILABLE_BRANCHES" | grep -q "^master$"; then
              BASE_BRANCH="master"
            else
              # Pega a primeira branch dispon√≠vel
              BASE_BRANCH=$(echo "$AVAILABLE_BRANCHES" | head -1)
            fi
            
            echo "‚úÖ Usando '${BASE_BRANCH}' como base"
            
            # Fetch da branch base se necess√°rio
            if [ "$(git branch --show-current)" != "${BASE_BRANCH}" ]; then
              git fetch origin "${BASE_BRANCH}:${BASE_BRANCH}" || true
              git checkout "${BASE_BRANCH}" || git checkout -b "${BASE_BRANCH}" "origin/${BASE_BRANCH}"
            fi
            
            # Cria nova branch
            git checkout -b "${BRANCH}"
            echo "üìç Nova branch criada: $(git branch --show-current)"
          fi

          # Instala yq se n√£o estiver dispon√≠vel
          if ! command -v yq &> /dev/null; then
            echo "üì¶ Instalando depend√™ncias..."
            sudo apt-get update -qq
            sudo apt-get install -y -qq jq curl
            
            # Download do yq com retry
            for i in {1..3}; do
              if curl -sSL "https://github.com/mikefarah/yq/releases/download/v4.45.1/yq_linux_amd64" -o yq; then
                chmod +x yq
                sudo mv yq /usr/local/bin/
                break
              else
                echo "‚ö†Ô∏è Tentativa ${i}/3 de download do yq falhou"
                [ $i -lt 3 ] && sleep 2
              fi
            done
            
            if ! command -v yq &> /dev/null; then
              echo "‚ùå Falha na instala√ß√£o do yq"
              exit 1
            fi
          fi

          echo "‚úÖ yq dispon√≠vel: $(yq --version 2>/dev/null || echo 'instalado')"

          # Define paths CORRETOS (sem barras extras)
          MANIFEST_PATH="k8s/apps/${CLEAN_APP_NAME}/${CLEAN_ENVIRONMENT}"
          DEPLOYMENT_MANIFEST="${MANIFEST_PATH}/deployment.yaml"
          SERVICE_MANIFEST="${MANIFEST_PATH}/service.yaml"

          echo "üìÅ Caminhos dos manifests:"
          echo "  Base: ${MANIFEST_PATH}"
          echo "  Deployment: ${DEPLOYMENT_MANIFEST}"
          echo "  Service: ${SERVICE_MANIFEST}"

          # Cria diret√≥rio se n√£o existir
          if [ ! -d "${MANIFEST_PATH}" ]; then
            echo "üìÅ Criando diret√≥rio: ${MANIFEST_PATH}"
            mkdir -p "${MANIFEST_PATH}"
          fi

          # Cria template do deployment se n√£o existir
          if [ ! -f "$DEPLOYMENT_MANIFEST" ]; then
            echo "üìù Criando deployment.yaml..."
            cat > "$DEPLOYMENT_MANIFEST" << EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: ${CLEAN_APP_NAME}-${CLEAN_ENVIRONMENT}
              namespace: ${CLEAN_ENVIRONMENT}
              labels:
                app: ${CLEAN_APP_NAME}
                environment: ${CLEAN_ENVIRONMENT}
            spec:
              replicas: 1
              selector:
                matchLabels:
                  app: ${CLEAN_APP_NAME}
                  environment: ${CLEAN_ENVIRONMENT}
              template:
                metadata:
                  labels:
                    app: ${CLEAN_APP_NAME}
                    environment: ${CLEAN_ENVIRONMENT}
                spec:
                  containers:
                  - name: ${CLEAN_APP_NAME}
                    image: ${IMAGE}
                    ports:
                    - containerPort: ${PORT}
                    env:
                    - name: ENVIRONMENT
                      value: ${CLEAN_ENVIRONMENT}
                    - name: APP_PORT
                      value: "${PORT}"
            EOF
                else
                  echo "‚úÖ deployment.yaml j√° existe"
                fi

                # Cria template do service se n√£o existir
                if [ ! -f "$SERVICE_MANIFEST" ]; then
                  echo "üìù Criando service.yaml..."
                  cat > "$SERVICE_MANIFEST" << EOF
            apiVersion: v1
            kind: Service
            metadata:
              name: ${CLEAN_APP_NAME}-${CLEAN_ENVIRONMENT}-service
              namespace: ${CLEAN_ENVIRONMENT}
              labels:
                app: ${CLEAN_APP_NAME}
                environment: ${CLEAN_ENVIRONMENT}
            spec:
              selector:
                app: ${CLEAN_APP_NAME}
                environment: ${CLEAN_ENVIRONMENT}
              ports:
              - protocol: TCP
                port: 80
                targetPort: ${PORT}
              type: ClusterIP
            EOF
                else
                  echo "‚úÖ service.yaml j√° existe"
                fi

                # Verifica se os arquivos foram criados corretamente
                if [ ! -f "$DEPLOYMENT_MANIFEST" ] || [ ! -f "$SERVICE_MANIFEST" ]; then
                  echo "‚ùå Erro: Manifests n√£o foram criados corretamente"
                  ls -la "${MANIFEST_PATH}/" || echo "Diret√≥rio n√£o existe"
                  exit 1
                fi

                # Atualiza manifests existentes
                echo "üîÑ Atualizando manifests com nova imagem..."
                echo "  üéØ Nova imagem: ${IMAGE}"
                echo "  üîå Nova porta: ${PORT}"

                # Backup dos arquivos antes da modifica√ß√£o
                cp "$DEPLOYMENT_MANIFEST" "${DEPLOYMENT_MANIFEST}.backup"
                cp "$SERVICE_MANIFEST" "${SERVICE_MANIFEST}.backup"

                # Aplica atualiza√ß√µes com verifica√ß√£o de erros
                echo "  üìù Atualizando deployment..."
                if ! yq e -i ".spec.template.spec.containers[0].image = \"${IMAGE}\"" "$DEPLOYMENT_MANIFEST"; then
                  echo "‚ùå Erro ao atualizar imagem no deployment"
                  exit 1
                fi

                if ! yq e -i ".spec.template.spec.containers[0].ports[0].containerPort = ${PORT}" "$DEPLOYMENT_MANIFEST"; then
                  echo "‚ùå Erro ao atualizar porta do container"
                  exit 1
                fi

                # Atualiza ENV var se existir
                if yq e '.spec.template.spec.containers[0].env[1]' "$DEPLOYMENT_MANIFEST" > /dev/null 2>&1; then
                  yq e -i ".spec.template.spec.containers[0].env[1].value = \"${PORT}\"" "$DEPLOYMENT_MANIFEST"
                  echo "  ‚úÖ Vari√°vel APP_PORT atualizada"
                else
                  echo "  ‚ÑπÔ∏è Vari√°vel APP_PORT n√£o encontrada (OK)"
                fi

                echo "  üìù Atualizando service..."
                if ! yq e -i ".spec.ports[0].targetPort = ${PORT}" "$SERVICE_MANIFEST"; then
                  echo "‚ùå Erro ao atualizar target port do service"
                  exit 1
                fi

                echo "‚úÖ Manifests atualizados com sucesso!"

                # Verifica altera√ß√µes e commit
                if git diff --quiet --exit-code; then
                  echo "‚ÑπÔ∏è Nenhuma altera√ß√£o detectada nos manifests"
                else
                  echo "üìù Altera√ß√µes detectadas. Preparando commit..."
                  
                  # Mostra um resumo das altera√ß√µes
                  echo "üìã Arquivos modificados:"
                  git diff --name-only | while read file; do
                    echo "  üìù ${file}"
                  done

                  git add "${MANIFEST_PATH}/"
                  
                  # Commit com informa√ß√µes detalhadas
                  COMMIT_MSG="Deploy ${CLEAN_APP_NAME} para ${CLEAN_ENVIRONMENT}

            - Imagem: ${IMAGE}
            - Porta: ${PORT}
            - Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

            [ci skip]"
                  
                  git commit -m "${COMMIT_MSG}"
                  
                  echo "üöÄ Fazendo push para origin/${BRANCH}..."
                  if git push origin "${BRANCH}"; then
                    echo "‚úÖ Manifests atualizados com sucesso!"
                    echo "üìã Commit: $(git log -1 --oneline)"
                  else
                    echo "‚ùå Erro no push. Tentando for√ßa..."
                    git push --set-upstream origin "${BRANCH}"
                  fi
                fi

                echo "üéâ Deploy finalizado com sucesso!"

      - name: Create/Update Monday Item
        if: success()
        env:
          MONDAY_API_TOKEN: ${{ secrets.MONDAY_API_TOKEN }}
          APP_NAME: ${{ env.APP_NAME }}
          IMAGE: ${{ env.IMAGE }}
          BOARD_ID: "10018892855"
        run: |
          set -eo pipefail
          ITEM_NAME="Deploy ${ENVIRONMENT} - $APP_NAME"
          IMAGE_INFO="Env: ${ENVIRONMENT} | Imagem: $IMAGE"
          echo "üöÄ Verificando item: $ITEM_NAME"

          QUERY=$(jq -n --arg board_id "$BOARD_ID" \
            '{query: "query { boards(ids: [\($board_id)]) { items_page { items { id name column_values { id text } } } } }"}')

          RESPONSE=$(curl -s -X POST https://api.monday.com/v2 \
            -H "Authorization: Bearer $MONDAY_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data-raw "$QUERY")

          if echo "$RESPONSE" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
            echo "üö´ Erro da API do Monday. Aborting."
            echo "$RESPONSE" | jq .
            exit 1
          fi

          ITEM_ID=$(echo "$RESPONSE" | jq -r --arg name "$ITEM_NAME" \
            '.data.boards[0].items_page.items[]? | select(.name == $name) | .id // empty')
          CURRENT_STATUS=$(echo "$RESPONSE" | jq -r --arg name "$ITEM_NAME" \
            '.data.boards[0].items_page.items[]? | select(.name == $name) | (.column_values? // []) | map(select(.id=="project_status"))[0].text // empty')

          echo "ITEM_ID=${ITEM_ID:-<empty>}"
          echo "CURRENT_STATUS=${CURRENT_STATUS:-<empty>}"

          if [ -z "$ITEM_ID" ]; then
            echo "‚ûï Criando item para ambiente ${ENVIRONMENT}..."
            case "$ENVIRONMENT" in
              "develop") INITIAL_STATUS="Para Teste" ;;
              "stage") INITIAL_STATUS="Para Teste" ;;
              "prod") INITIAL_STATUS="Aprovado para Prod" ;;
              *) INITIAL_STATUS="N√£o iniciado" ;;
            esac

            COLUMN_VALUES=$(jq -n --arg info "$IMAGE_INFO" --arg status "$INITIAL_STATUS" \
              '{project_status: {label: $status}, text_mkvn9dqm: $info}')
            COLUMN_VALUES_ESCAPED=$(echo "$COLUMN_VALUES" | jq -Rs .)
            PAYLOAD=$(jq -n --arg name "$ITEM_NAME" --arg board_id "$BOARD_ID" --arg colvals "$COLUMN_VALUES_ESCAPED" \
              '{query: "mutation { create_item(board_id: \($board_id|tonumber), item_name: \"\($name)\", column_values: \($colvals)) { id name } }"}')

            CREATE_RESP=$(curl -s -X POST https://api.monday.com/v2 \
              -H "Authorization: Bearer $MONDAY_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data-raw "$PAYLOAD")

            if echo "$CREATE_RESP" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
              echo "üö´ Erro ao criar item no Monday."
              echo "$CREATE_RESP" | jq .
              exit 1
            fi
            echo "‚úÖ Item criado com sucesso para ${ENVIRONMENT}!"
          else
            echo "üîÑ Atualizando item existente para ${ENVIRONMENT}..."
            IMAGE_ESCAPED=$(echo "$IMAGE_INFO" | jq -Rs .)
            UPDATE_PAYLOAD=$(jq -n --arg item_id "$ITEM_ID" --arg board_id "$BOARD_ID" --arg info "$IMAGE_ESCAPED" \
              '{query: "mutation { change_simple_column_value(board_id: \($board_id|tonumber), item_id: \($item_id|tonumber), column_id: \"text_mkvn9dqm\", value: \($info)) { id } }"}')

            UPDATE_RESP=$(curl -s -X POST https://api.monday.com/v2 \
              -H "Authorization: Bearer $MONDAY_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data-raw "$UPDATE_PAYLOAD")

            if echo "$UPDATE_RESP" | jq -e '.errors? | length > 0' > /dev/null 2>&1; then
              echo "üö´ Erro ao atualizar item no Monday."
              echo "$UPDATE_RESP" | jq .
              exit 1
            fi
            echo "‚úÖ Item atualizado com sucesso para ${ENVIRONMENT}!"
          fi

      - name: üéâ Deploy Summary
        if: always()
        run: |
          echo "=========================================="
          echo "üéâ DEPLOY FINALIZADO"
          echo "=========================================="
          echo "üéØ AMBIENTE: ${ENVIRONMENT^^}"
          echo "üåê BRANCH: ${{ github.ref_name }}"
          echo "üèóÔ∏è Aplica√ß√£o: ${APP_NAME}"
          echo "üé® Imagem: ${IMAGE}"
          echo "üìÅ Manifests: ${MANIFEST_PATH}"
          echo "üåê Porta: ${APP_PORT}"
          echo "üìä Status: ${{ job.status }}"
